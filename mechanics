# Miscellaneous and constants
def factorial(number):
    if number == 0:
        return 1
    else:
        total = 1
        for i in range(number, 0, -1):
            total *= i

        return total


def magnitude(number):
    if number < 0:
        number *= -1
        return number
    else:
        return number

e = 2.718281828459045
pi = 3.141592653589793

class SimultaneousEquation2:
    def __init__(self, x1, y1, z1, x2, y2, z2):
        # assign variables so we can later on make a matrix
        self.x1 = x1
        self.y1 = y1
        self.z1 = z1
        self.x2 = x2
        self.y2 = y2
        self.z2 = z2

    def assemble_matrix(self):  # assemble a matrix for the rhs, as the lhs will cancel upon multiplication with inverse
        rhs = [[self.z1], [self.z2]]
        return rhs

    def determinant(self):
        output = (self.x1 * self.y2) - (self.y1 * self.x2)
        return output

    def inverse_matrix(self):
        determinant = self.determinant()
        new_x1 = self.y2 / determinant
        new_y1 = (-1 * self.y1) / determinant
        new_x2 = (-1 * self.x2) / determinant
        new_y2 = self.x1 / determinant
        # assemble the inverse matrix
        new_matrix = [[new_x1, new_y1], [new_x2, new_y2]]
        return new_matrix

    def solve_equation(self):
        inv_mat = self.inverse_matrix()
        rhs_mat = self.assemble_matrix()
        x = (inv_mat[0][0] * rhs_mat[0][0]) + (inv_mat[0][1] * rhs_mat[1][0])
        y = (inv_mat[1][0] * rhs_mat[0][0]) + (inv_mat[1][1] * rhs_mat[1][0])
        return x, y


#Trig

def radians(degrees):
    radians = degrees * (pi / 180)
    return radians


def sin(x):
    approx_value = x
    iteration_counter = 0
    for r in range(3, 50, 2):
        iteration_counter += 1
        if iteration_counter % 2 == 0:
            approx_value += ((x ** (r)) / (factorial(r)))
        else:
            approx_value -= ((x ** (r)) / (factorial(r)))

    return approx_value


def degrees(radians):
    degrees = radians * (180 / pi)
    return degrees


def cos(x):
    approx_value = 1
    iteration_counter = 0
    for r in range(2, 50, 2):
        iteration_counter += 1
        if iteration_counter % 2 == 0:
            approx_value += ((x ** (r)) / (factorial(r)))
        else:
            approx_value -= ((x ** (r)) / (factorial(r)))

    return approx_value


def arctan(x, num_terms=10):
    """
    Approximates arctan(x) using a Taylor series expansion.

    :param x: input value
    :param num_terms: number of terms to use in the Taylor series (default: 10)
    :return: approximate value of arctan(x)
    """
    result = 0
    for i in range(num_terms):
        sign = (-1) ** i
        result += ((x ** (2 * i + 1)) / (2 * i + 1)) * sign
    return result


## MECHANICS

class EC2D:  # Elastic Collisions in 2d
    def __init__(self, angle_of_approach, coefficient_of_restitution, speed_of_approach):
        self.angle_of_approach = angle_of_approach
        self.e = coefficient_of_restitution
        self.u = speed_of_approach  # u is initial velocity

    def horizontal_components(self):
        horizontal = self.u * cos(radians(self.angle_of_approach))
        return horizontal

    def vertical_components(self):
        vertical = self.u * sin(radians(self.angle_of_approach)) * self.e
        return vertical

    def speed_of_rebound(self):
        speed = ((self.horizontal_components() ** 2) + (self.vertical_components() ** 2)) ** 0.5
        return speed

    def angle_of_deflection(self):
        angle_2 = arctan(self.vertical_components() / self.horizontal_components())  # this is given in radians
        angle_of_deflection = degrees(angle_2) + self.angle_of_approach
        return angle_of_deflection


class Elastic:
    def __init__(self, modulus_of_elasticity, extension, natural_length):
        self.modulus_of_elasticity = modulus_of_elasticity
        self.extension = extension
        self.natural_length = natural_length

    def tension(self):
        tension = (self.modulus_of_elasticity * self.extension) / self.natural_length
        return tension

    def epe(self):
        epe = ((self.modulus_of_elasticity) * (self.extension ** 2)) / (
                    2 * self.natural_length)  # epe measured in Joules
        return epe


class EC1D: #Assuming ðŸ¡ª is positive velocity ( as we are dealing with velocities not speed)

    def __init__(self, initial_velocity, coefficient_of_restitution, mass):
        self.inital_velocity = initial_velocity
        self.coefficient_of_restitution = coefficient_of_restitution
        self.mass = mass

    def collision_with_object(self,second_initial_velocity,second_mass):
        #assume the first object to have the positive velocity
        x1,y1,z1 = self.restitution_equation(second_initial_velocity)
        x2,y2,z2 = self.clm(second_initial_velocity,second_mass)
        #assemble a 2x2 matrix to solve the equation
        matrix = SimultaneousEquation2(x1,y1,z1,x2,y2,z2)
        v1,v2 =  (matrix.solve_equation())
        return (f"Assuming that ðŸ¡ª is the positive direction,v1 = {v1} , v2 = {v2}")

    def collision_with_plane(self):
        #Assuming ðŸ¡ª is positive velocity ( as we are dealing with velocities not speed)
        speed_of_rebound = (self.inital_velocity) * (self.coefficient_of_restitution)
        return speed_of_rebound

    def restitution_equation(self,second_initial_velocity):
        #assume the first object to have the positive velocity
        z1 = magnitude(second_initial_velocity - self.inital_velocity ) * self.coefficient_of_restitution
        #assuming the two objects are going in the same direction
        # -v1 + v2 = (-u1 + u2)e
        return -1,1,z1

    def clm(self,second_initial_velocity,second_mass):
        z2 = (self.inital_velocity * self.mass) + (second_initial_velocity * second_mass)
        x2 = self.mass
        y2 = second_mass
        return x2,y2,z2





b= EC1D(4,0.2,2)
print(b.collision_with_plane())
