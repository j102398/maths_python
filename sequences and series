#misc functions

def magnitude(number): #returns |number|
    if number < 0:
        number *= -1
    else:
        pass
    return number

def SieveOfEratosthenes(n):  #used for generating a list of prime numbers up to n
    # Create a list to store boolean values representing whether each number is prime or not
    prime_numbers = [True for i in range(n + 1)]

    # Mark 0 and 1 as not prime numbers, as they are not
    prime_numbers[0] = prime_numbers[1] = False

    # Create an empty list to store the prime numbers
    prime_numbers_list = []

    # Start looping from 2, the first prime number
    p = 2
    while p <= (n ** 0.5):
        # If the current number is marked as prime
        if prime_numbers[p] == True:
            # Add it to the list of prime numbers
            prime_numbers_list.append(p)
            # Mark all multiples of p as not prime
            # Start from p * p, because all smaller multiples would have already been marked by smaller prime numbers
            # For example, if p is 5, we start from 25, because all smaller multiples like 10, 15, 20 would have been marked by 2, 3, etc.
            for i in range(p * p, n + 1, p):
                # Mark i as not prime
                prime_numbers[i] = False
        # Move on to the next number
        p += 1

    # Loop through the remaining numbers to find any additional prime numbers
    for p in range(int(n ** 0.5) + 1, n + 1):
        # If the current number is still marked as prime
        if prime_numbers[p]:
            # Add it to the list of prime numbers
            prime_numbers_list.append(p)

    # Return the list of prime numbers
    return prime_numbers_list

print(SieveOfEratosthenes(120))





#arithmetic sequence in the form un = a + (n-1)D
#WHERE a is the first term, n is the term number and d is the linear difference between terms


class ArithmeticSequence:
    def __init__(self,a,d):
        self.a = a
        self.d = d

    def term(self,n):
        term = self.a + ((n-1)*self.d)
        return term

#Arithmetic series

class ArithmeticSeries:
    def __init__(self,a,d):
        self.a = a
        self.d = d

    def sum(self,n):
        #summing up to n
        summation = (0.5 * n) * ((2*self.a) + ((n-1)*d))
        return summation

#geometric sequence in the form un = a * r^(n-1)

class GeometricSequence:
    def __init__(self,a,r):
        self.a = a
        self.r = r

    def term(self,n):
        term = (self.a) * ((self.r)**(n-1))
        return term

#Geometric series and summing to infinity where applicable

class GeometricSeries:
    def __init__(self,a,r):
        self.a = a
        self.r = r

    def sum(self,n):
        sum = (self.a*(1-(self.r**(n)))) / (1-self.r)
        return sum

    def infinitysum(self):
        #can only sum to infinity if |r| < 1
        if magnitude(self.r) < 1:
            sum = self.a / (1-self.r)
            return sum
        else:
            return "|r| >= 1,cannot sum to infinity"


